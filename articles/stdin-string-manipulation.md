---
title: "ã‚³ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°è©¦é¨“ã§è§£ã„ãŸæ–‡å­—åˆ—æ“ä½œã‚’ç´°ã‹ãè§£èª¬ã—ã¦ã¿ã‚‹"
emoji: "ğŸ˜½"
type: "tech" # tech: æŠ€è¡“è¨˜äº‹ / idea: ã‚¢ã‚¤ãƒ‡ã‚¢
topics: ["go", "golang"] # ã‚¿ã‚°å
published: false # å…¬é–‹è¨­å®š
---

## åˆã‚ã«

ã¨ã‚ã‚‹ã‚³ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°è©¦é¨“ã§ä»¥ä¸‹ã®ã‚ˆã†ãªå•é¡ŒãŒå‡ºã¾ã—ãŸã€‚

Q: æ–‡ç« ä¸­ã«ã‚¢ãƒ«ãƒ•ã‚¡ãƒ™ãƒƒãƒˆå¤§æ–‡å­—ã¾ãŸã¯æ•°å­—ã‹ã‚‰å§‹ã¾ã‚‹å˜èªãŒä½•ç¨®é¡ã‚ã‚‹ã‹æ•°ãˆã¦ãã ã•ã„ã€‚

æ¡ä»¶: å˜èªã®å€‹æ•°ãªã®ã§é‡è¤‡ã¯ã‚«ã‚¦ãƒ³ãƒˆã—ã¾ã›ã‚“ã€‚

å…¥åŠ›ã¯æ¨™æº–å…¥åŠ›ã‹ã‚‰å–å¾—ã—ã¦ã€æœ€å¾Œã«å‡ºåŠ›ã—ã¾ã™ã€‚

ex) input

`Favorite food is yakiniku. Age is 25 years old. Favorite hobby is coding.`

ã“ã®å•é¡Œã‚’è§£ãéš›ã«å­¦ã‚“ã ã“ã¨ãŒæ²¢å±±ã‚ã£ãŸã®ã§ã€ã¾ã¨ã‚ã¾ã—ãŸã€‚

## æœ€åˆã«è€ƒãˆãŸã“ã¨

1. ã¾ãšã¯ç©ºç™½ã¨ãƒ”ãƒªã‚ªãƒ‰ã§æ–‡å­—ã‚’åŒºåˆ‡ã£ã¦æ–°ã—ãã‚¹ãƒ©ã‚¤ã‚¹ã‚’ä½œæˆã™ã‚‹
2. é‡è¤‡ã‚’åˆ¤å®šã™ã‚‹é–¢æ•°ã‚’ç”¨æ„ã—ã¦ã€é‡è¤‡ã‚’å–ã‚Šé™¤ã„ãŸæ–°ã—ã„ã‚¹ãƒ©ã‚¤ã‚¹ã‚’ä½œæˆã™ã‚‹
3. ã‚¹ãƒ©ã‚¤ã‚¹ã‚’ for ~ range ã§å›ã—ã¦ã„ãã€æ–‡å­—ã‚’å–å¾—ã—ã¦ã€å¤§æ–‡å­—ã‹å°æ–‡å­—ã‹åˆ¤å®šã™ã‚‹

ã“ã®ã‚ˆã†ã«æœ€åˆã«æ•´ç†ã—ã¦è€ƒãˆã¾ã—ãŸã€‚

æœ€åˆã«å…¨ã¦ã®ã‚³ãƒ¼ãƒ‰ã‚’æç¤ºã—ã¦ã‚‚åˆ†ã‹ã‚Šè¾›ã„ã®ã§ã€main é–¢æ•°ã‹ã‚‰æœ€å¾Œã¾ã§åˆ‡ã‚Šåˆ†ã‘ã¦è§£èª¬ã—ã¾ã™ã€‚

## ã‚¨ãƒ³ãƒˆãƒªãƒ¼ãƒã‚¤ãƒ³ãƒˆ (main é–¢æ•°)

```go
func main() {
    scanner := bufio.NewScanner(os.Stdin)
    scanner.Scan()
    text := scanner.Text()
    fmt.Printf("Solution(text): %v\n", Solution(text))
}
```

`func NewScanner(r io.Reader) *Scanner`

Scanner å‹ã¯ã€æ¨™æº–å…¥åŠ›ã‚„ãƒ•ã‚¡ã‚¤ãƒ«ã‹ã‚‰ã®ãƒ‡ãƒ¼ã‚¿ã®èª­ã¿è¾¼ã¿ã‚„ã€æ–‡å­—åˆ—ã‚’æŒ‡å®šã®åŒºåˆ‡ã‚Šã§åˆ†å‰²ã™ã‚‹æ©Ÿèƒ½ã‚’æä¾›ã—ã¦ãã‚Œã¾ã™ã€‚
å¼•æ•°ã«ã¯ io.Reader å‹ => io.Reader interface ã¯ã€èª­ã¿è¾¼ã¿å¯èƒ½ãªãƒ‡ãƒ¼ã‚¿ã‚’è¡¨ç¾ã™ã‚‹ãŸã‚ã®ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹ã‚’æä¾›ã—ã¾ã™ã€‚
ãªã®ã§èª­ã¿å–ã‚Šå¯èƒ½ãªãƒ‡ãƒ¼ã‚¿ã‚’å¼•æ•°ã«ã¨ã£ã¦ã‚ã’ã¾ã™ã€‚

ã“ã“ã§è¨­å®šã™ã‚‹ os.Stdin ã¯ã€æ¨™æº–å…¥åŠ›ã‚’è¡¨ã™ os.File å‹ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã§ã‚ã‚Šã€
`Stdin = NewFile(uintptr(syscall.Stdin), "/dev/stdin")`
`func NewFile(fd uintptr, name string) *File`ã§ã™ã€‚

bufio.NewScanner()ã«æ¸¡ã™ã“ã¨ã§ã€æ¨™æº–å…¥åŠ›ã‹ã‚‰èª­ã¿è¾¼ã¿ã‚’è¡Œã†ã‚ˆã¨æœ€åˆã«è¨­å®šã—ã¾ã™ã€‚

- ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ
  ã€ŒScanner å‹ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’ä½œæˆã™ã‚‹ã€ã¨ã„ã†è¡¨ç¾ã«ãŠã„ã¦ã€ã“ã®ã€Œã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã€ã¨ã¯å¤‰æ•°ã‚„é–¢æ•°ã€æ§‹é€ ä½“ãªã©ã®å®Ÿä½“ã®ã“ã¨ã§ã™ã€‚
  è¦ã™ã‚‹ã«ã€æ§‹é€ ä½“ã®ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ç­‰ã‚’åŸ‹ã‚ã‚‹ä½œæ¥­ã‚’è¡Œã„ã€å®Ÿä½“ã‚’ä½œæˆã™ã‚‹ã¨ã„ã†ã“ã¨ã«ãªã‚Šã¾ã™ã€‚

`scanner.Scan()`

scanner.Scan()ã¯ã€å®Ÿéš›ã®æ¨™æº–å…¥åŠ›ã‹ã‚‰ãƒ‡ãƒ¼ã‚¿ã‚’èª­ã¿å–ã‚Šã€ãã®ãƒ‡ãƒ¼ã‚¿ã‚’ç©ºç™½æ–‡å­—ã§åŒºåˆ‡ã£ã¦ 1 ã¤ã®ãƒˆãƒ¼ã‚¯ãƒ³ã¨ã—ã¾ã™ã€‚

ãã®ãƒˆãƒ¼ã‚¯ãƒ³ã¯ scanner ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã® token ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã«ä¸€æ™‚çš„ã«ä¿æŒã—ã¾ã™ã€‚

æ§‹é€ ä½“ã®ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã«ãƒˆãƒ¼ã‚¯ãƒ³ã¨ã—ã¦ä¿å­˜ã™ã‚‹ã ã‘ãªã®ã§ã€ç‰¹ã«æˆ»ã‚Šå€¤ã®åˆ©ç”¨ã¯ãªã„å‡¦ç†ã«ãªã‚Šã¾ã™ã€‚

`text := scanner.Text()`

scanner.Scan()ã§ scanner æ§‹é€ ä½“ã® token ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã‚’èª­ã¿å–ã‚Šã€èª­ã¿è¾¼ã‚“ã ãƒˆãƒ¼ã‚¯ãƒ³ã‚’æ–‡å­—åˆ—ã¨ã—ã¦è¿”ã—ã¾ã™ã€‚

## å®Ÿéš›ã«å‡¦ç†ã™ã‚‹éƒ¨åˆ†

```go
func Solution(str string) int {

    slice := strings.FieldsFunc(str, func(r rune) bool {
        return unicode.IsSpace(r) || r == '.'
    })
    uniqueSlice := DeleteDuplicate(slice) // é‡è¤‡ã®å‰Šé™¤
    for _, v := range uniqueSlice {
        initial := v[0:1]
    ok := CheckRegex(initial)
    if ok {
        count++
    }
    }
    return count
}
```

```go
    slice := strings.FieldsFunc(str, func(r rune) bool {
        return unicode.IsSpace(r) || r == '.'
    })
```

`func FieldsFunc(s string, f func(rune) bool) []string {}`

ã“ã“ã§ã¯ã¾ãš 1 ã¤ 1 ã¤ã®å˜èªã«ã‚¢ã‚¯ã‚»ã‚¹ã—ã¦ã€ç©ºç™½ã¨ãƒ”ãƒªã‚ªãƒ‰ã§åˆ†å‰²ã™ã‚‹ã‚ˆã†ã«è¨­å®šã—ã¾ã™ã€‚
ç„¡åé–¢æ•°ãŒå¼•æ•°ã®å ´åˆã¯ãã®é€šã‚Šã«ã‚·ã‚°ãƒ‹ãƒãƒ£ã‚’ç”¨æ„ã™ã‚Œã° OK ã§ã™ã€‚
æˆ»ã‚Šå€¤ã¨ã—ã¦ç©ºç™½ã¨ãƒ”ãƒªã‚ªãƒ‰ã‚’é™¤ã„ãŸã‚¹ãƒ©ã‚¤ã‚¹ã‚’è¿”ã—ã¾ã™ã€‚

ãã®çµæœã®å¤‰æ•° slice ã¯ä»¥ä¸‹ã®ã‚ˆã†ãªå€¤ã‚’æŒã£ã¦ã„ã¾ã™ã€‚

`["Favorite" "food" "is" "yakiniku" "Age" "is" "25" "years" "old" "Favorite" "hobby" "is" "coding"]`

ãã®å¾Œã€é‡è¤‡ã‚’å‰Šé™¤ã™ã‚‹é–¢æ•°ãŒå‘¼ã³å‡ºã•ã‚Œã¾ã™ã€‚

```go
func DeleteDuplicate(strings []string) []string {
    var unique []string
    m := map[string]bool{}
    for _, v := range strings {
        if len(word) == 0 {
            continue
        }
        if _, ok := m[v]; !ok {
            m[v] = true
            unique = append(unique, v)
        }
    }
    return unique
}
```

ã¾ãšé‡è¤‡ã‚’é™¤ã„ãŸã‚¹ãƒ©ã‚¤ã‚¹ã‚’æ–°ã—ãä½œæˆã—ãŸã„ã®ã§`var unique []string`ã¨å®£è¨€ã—ã¾ã™ã€‚

ã“ã“ã§ã®ãƒã‚¤ãƒ³ãƒˆã¯ã©ã†é‡è¤‡ã—ã¦ã„ã‚‹ã‹ã©ã†ã‹ã‚’åˆ¤å®šã™ã‚‹ã‹ã¨ã„ã†ã“ã¨ã§ã™ã€‚
`m := map[string]bool{}`ã¨ã„ã†å¤‰æ•°ã‚’ç”¨æ„ã—ã¦ã€ã“ã¡ã‚‰ã‚’ä½¿ã„ã¾ã™ã€‚
ã¾ãš map å‹ã®æ€§è³ªã¨ã—ã¦ã€åŒã˜ã‚­ãƒ¼ãŒä¿å­˜ã•ã‚Œã‚‹ã“ã¨ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚

å‚è€ƒä¾‹

```go
    m := make(map[string]int)
    m.key1 = 1
    m.key2 = 2
    m.key1 = 5 // ä¸Šæ›¸ãã™ã‚‹

    fmt.Println(m)
    // -> [key1: 5, key2: 2]
```

ã¾ãŸç©ºã®æ–‡å­—åˆ—ãŒå«ã¾ã‚Œã‚‹å ´åˆãŒã‚ã‚‹ã®ã§ã€ä»¥ä¸‹ã¯ãã‚Œã‚’ã‚¹ãƒ«ãƒ¼ã™ã‚‹è¨˜è¿°ã§ã™ã€‚
ä¾‹ãˆã°æœ€åˆã®æ–‡å­—åˆ—ãŒç©ºç™½ã ã£ãŸã‚Šã€ãƒ”ãƒªã‚ªãƒ‰ã§çµ‚ã‚ã£ãŸæ–‡ç« ã§ç©ºã®æ–‡å­—åˆ—ãŒå…¥ã£ã¦ã—ã¾ã†ã“ã¨ãŒã‚ã‚‹ã‹ã‚‰ã§ã™ã€‚

```go
    if len(word) == 0 {
        continue
    }
```

ãã®å¾Œã€åŒºåˆ‡ã‚‰ã‚ŒãŸæ–‡å­—åˆ—ã®ã‚¹ãƒ©ã‚¤ã‚¹ã‚’ãã‚Œãã‚Œã‚¢ã‚¯ã‚»ã‚¹ã—ã¦ã„ã£ã¦ã€é‡è¤‡ãŒã©ã†ã‹ã‚’åˆ¤å®šã—ã¾ã™ã€‚
`m[v] -> m["Favorite"]`ã¨ã‚­ãƒ¼ã«ã‚¢ã‚¯ã‚»ã‚¹ã—ã€map ã®ãƒãƒªãƒ¥ãƒ¼ãŒ true ã‹ false ã§åˆ¤å®šã—ã¾ã™ã€‚
è¦ã™ã‚‹ã« true ã§ã‚ã‚Œã°æ—¢ã«ã‚­ãƒ¼ã¯å­˜åœ¨ã—ã¦ã„ã‚‹ã¨ã„ã†ã“ã¨ã«ãªã‚Šã¾ã™ã€‚
ã“ã®ã‚ˆã†ã«å˜èªåˆ†ç¹°ã‚Šè¿”ã—ã¦ã„ãã€é‡è¤‡ã‚’é™¤ã„ãŸã‚¹ãƒ©ã‚¤ã‚¹ã‚’ æˆ»ã‚Šå€¤ã¨ã—ã¦è¿”ã—ã¾ã™ã€‚

```go
func Solution(str string) int {

    slice := strings.Split(str, " ")
    uniqueSlice := DeleteDuplicate(slice) // é‡è¤‡ã®å‰Šé™¤

    for _, v := range uniqueSlice {
        initial := v[0:1]
    ok := CheckRegex(initial)
    if ok {
        count++
    }
    }
    return count
}
```

ã•ã‚‰ã«é‡è¤‡ã‚’é™¤ã„ãŸã‚¹ãƒ©ã‚¤ã‚¹ã‚’ for range ã§å›ã—ã¦ã€v[0:1]ã¨ã—ã¦é ­æ–‡å­—ã«ã‚¢ã‚¯ã‚»ã‚¹ã—ã¾ã™ã€‚
ãã—ã¦ CheckRegex()ã¨ã—ã¦é–¢æ•°ã‚’ç”¨æ„ã—ã¾ã™ã€‚

```go
regex := regexp.MustCompile(`[A-Z0-9]`) // æº–å‚™

func CheckRegex(s string) bool {
    ok := regex.MatchString(s)  // åˆ¤å®š
    return ok
}
```

ã“ã“ã§åˆ¤å®šã‚’è¡Œã„ã¾ã™ã€‚å°š `regex := regexp.MustCompile(`[A-Z0-9]`)` ã¯ä¸€åº¦ã®ã¿ã®å®Ÿè¡Œã§ã„ã„ã®ã§ CheckRegex()å¤–ã§å®£è¨€ã—ã¦ã„ã¾ã™ã€‚
regex.MatchString()ã§ true ã§ã‚ã‚Œã°å¤§æ–‡å­— or æ•°å­— ã¨ã—ã¦ã‚«ã‚¦ãƒ³ãƒˆã—ã¦æœ€å¾Œã«å‡ºåŠ›ã—ã¦çµ‚äº†ã§ã™ã€‚

### å…¨ä½“ã®ã‚³ãƒ¼ãƒ‰

```go
package main

import (
    "bufio"
    "fmt"
    "os"
    "regexp"
    "strings"
)

var count int

func Solution(str string) int {
    slice := strings.FieldsFunc(str, func(r rune) bool {
        return unicode.IsSpace(r) || r == '.'
    })
    uniqueSlice := DeleteDuplicate(slice) // é‡è¤‡ã®å‰Šé™¤
    for _, v := range uniqueSlice {
        initial := v[0:1]
        ok := CheckRegex(initial)
        if ok {
            count++
        }
    }
    return count
}

func DeleteDuplicate(strings []string) []string {
    // m[""]false ãŒåˆæœŸåŒ–ã—ãŸéš›ã®å‹
    m := make(map[string]bool)

    var unique []string
    for _, v := range strings {
        if len(word) == 0 {
            continue
        }
        // m[v]ãŒtrueã§ãªã‘ã‚Œã° = ã¾ã ãã®ã‚­ãƒ¼ã¯ãªã„ã¨ã„ã†ã“ã¨
        if _, ok := m[v]; !ok {
            m[v] = true
            unique = append(unique, v)
        }
    }
    return unique

}

var regex = regexp.MustCompile(`[A-Z0-9]`) // æº–å‚™

func CheckRegex(s string) bool {
    ok := regex.MatchString(s) // åˆ¤å®š
    return ok
}
```

### ä¸Šè¨˜ã®æ”¹å–„ç‚¹

ä¸€å¿œä¸Šè¨˜ã§ã®ã‚³ãƒ¼ãƒ‰ã§ã‚‚å‹•ãã®ã§ã™ãŒã€

`strings.FieldsFunc()`ã§ã‚‚å…¨ã¦ã‚’èª­ã¿è¾¼ã‚€ã¨ãªã‚‹ã¨ã€ãƒ†ã‚­ã‚¹ãƒˆãƒ•ã‚¡ã‚¤ãƒ«ã®ã‚µã‚¤ã‚ºãŒå¤§ãã„ã¨å¤‰æ•°ã®å®¹é‡ã‚‚å¢—åŠ ã—ã€
å¤‰æ•°ã®ã‚µã‚¤ã‚ºãŒå¤§ãããªã‚‹ã¨ãƒ¡ãƒ¢ãƒªç¢ºä¿ã‚„ã‚³ãƒ”ãƒ¼ãªã©ã«æ™‚é–“ãŒã‹ã‹ã‚Šã¾ã™ã€‚

ä»Šå›å…¨ã¦ã®ãƒ†ã‚­ã‚¹ãƒˆæƒ…å ±ã‚’ä¿æŒã—ãªãã¦ã‚‚ã€æ–‡å­—åˆ—ã‚’ã‚¹ãƒšãƒ¼ã‚¹ç­‰ãŒæ¥ã‚‹ã¾ã§é †ç•ªã«èª­ã¿å–ã£ã¦å‡¦ç†ã‚’è¡Œã„ã€
å˜èªã®é‡è¤‡ãƒã‚§ãƒƒã‚¯ã‚’è¡Œãªã£ã¦ã„ãã“ã¨ã§æ—¢ã«å‡¦ç†ã—ãŸæ–‡å­—åˆ—ã‚’ç ´æ£„ã™ã‚‹ã“ã¨ãŒå‡ºæ¥ã‚‹ã‚ˆã†ãªãƒ­ã‚¸ãƒƒã‚¯ã§ã‚‚æ›¸ãã“ã¨ãŒå‡ºæ¥ã¾ã—ãŸã€‚

### æ–¹æ³• 2

```go
    scanner := bufio.NewScanner(os.Stdin)

    // ã©ã®ã‚ˆã†ã«åŒºåˆ‡ã‚‹ã‹ã®è¨­å®šã‚’è¡Œã†
    scanner.Split(func(data []byte, atEOF bool) (advance int, token []byte, err error) {
        // ç©ºç™½ã§åŒºåˆ‡ã‚‹
        for i := 0; i < len(data); i++ {
            if data[i] == ' ' || data[i] == '.' {
                return i + 1, data[:i], nil
            }
        }
        return 0, data, bufio.ErrFinalToken
    })
```

ã¾ãšåŒºåˆ‡ã‚‹è¨­å®šã‚’è¡Œã„ã¾ã™ã€‚Split()ã«ã¯ç„¡åé–¢æ•°ã‚’æ¸¡ã—ã¾ã™ã€‚

```go
    words := map[string]struct{}{}
    for scanner.Scan() {
        word := scanner.Text()
        if len(word) == 0 {
            continue
        }
        capital := rune(word[0]) // runeã§æ¯”è¼ƒã—ãŸã„ã®ã§å¤‰æ›ã™ã‚‹
        if unicode.IsUpper(capital) || unicode.IsDigit(capital) {
            // ä¸€è‡´ã—ãŸã‚‰ã‚­ãƒ¼ã«ãã®å˜èªã‚’ã€å€¤ã¯ç©ºã§è¨­å®šã™ã‚‹
            words[word] = struct{}{}
        }
    }
    if err := scanner.Err(); err != nil {
        panic(err)
    }
    fmt.Printf("%d words\n\n", len(words))
    // mapã‚’for range ã§å›ã™
    for word := range words {
        fmt.Println(word)
    }
```

æœ€åˆã«`words := map[string]struct{}{}`ã¨ã‚ã‚Šã¾ã™ãŒã€ã“ã¡ã‚‰ã‚‚é‡è¤‡ã‚’ãƒã‚§ãƒƒã‚¯ã™ã‚‹ãŸã‚ã«ç”¨æ„ã—ã¦ã„ã¾ã™ã€‚å¾Œã»ã©èª¬æ˜ã—ã¾ã™ã€‚

ã¾ãšã€scanner.Scan()ã¯æ¨™æº–å…¥åŠ›ç©ºç™½ã§åŒºåˆ‡ã£ã¦(ç©ºç™½ä»¥å¤–ã®åŒºåˆ‡ã‚Šã«ã‚‚å‡ºæ¥ã‚‹ãŒãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã¯ç©ºç™½)ã€ãƒ‡ãƒ¼ã‚¿ã‚’ç©ºç™½æ–‡å­—ã§åŒºåˆ‡ã£ã¦ 1 ã¤ã®ãƒˆãƒ¼ã‚¯ãƒ³ã¨ã—ã¾ã™ã€‚
ãã®ãƒˆãƒ¼ã‚¯ãƒ³ã¯ scanner ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã® token ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã«ä¸€æ™‚çš„ã«ä¿æŒã—ã¾ã™ã€‚ãªã®ã§ã“ã‚Œã‚’åˆ©ç”¨ã—ã¦ã€1 ã¤ 1 ã¤æ–‡å­—ã‚’è¦‹ã¦ã„ã‘ã°ã„ã„ã ã‘ã§ã™ã€‚

`word[0]`ã¨ã‚¢ã‚¯ã‚»ã‚¹ã™ã‚‹ã¨ã€1 æ–‡å­—ãŒ byte å‹ã§è¿”ã£ã¦ãã‚‹ãŸã‚ã€rune å‹ã«å¤‰æ›ã—ã¾ã™ã€‚

rune å‹ã«é–¢ã—ã¦ã§ã™ãŒã€
ã‚³ãƒ³ãƒ”ãƒ¥ãƒ¼ã‚¿ãƒ¼ã¯æ–‡å­—ã‚’ç›´æ¥æ‰±ã†ã“ã¨ãŒå‡ºæ¥ã¾ã›ã‚“ã€‚å®Ÿè¡Œã™ã‚‹ã¨ãã‚‚ 0 ã¨ 1 ã® 2 é€²æ•°ã®æ©Ÿæ¢°èªã‚’ç”¨ã„ã¦ã€å®Ÿè¡Œã—ã¾ã™ã€‚
ãªã®ã§ "ã‚" ã¨ã„ã†æ–‡å­—ã«å¯¾å¿œã—ãŸæ•°å­—ã‚’ç”¨æ„ã—ã¦(Unicode ã‚³ãƒ¼ãƒ‰ãƒã‚¤ãƒ³ãƒˆ)ã€2 é€²æ•°ã«å¤‰æ›ã—ã‚ˆã†ã¨ã„ã†ä»•çµ„ã¿ãŒå¿…è¦ã§ã™ã€‚
ãã‚ŒãŒ Unicode ã¨ã„ã£ãŸæ–‡å­—ã‚³ãƒ¼ãƒ‰ã«ãªã‚Šã¾ã™ã€‚

ä¾‹ãˆã°ã€Unicode ã‚³ãƒ¼ãƒ‰ãƒã‚¤ãƒ³ãƒˆã¨ã—ã¦ 16 é€²æ•°ã® "0041" ãŒå‰²ã‚Šå½“ã¦ã‚‰ã‚ŒãŸæ–‡å­— "A" ã‚’æ‰±ã†å ´åˆã€ã‚³ãƒ³ãƒ”ãƒ¥ãƒ¼ã‚¿ãƒ¼ã¯ä»¥ä¸‹ã®ã‚ˆã†ã«å‡¦ç†ã—ã¾ã™ã€‚

1. Unicode ã‚³ãƒ¼ãƒ‰ãƒã‚¤ãƒ³ãƒˆ "0041" ã‚’ 2 é€²æ•°è¡¨ç¾ã«å¤‰æ›ã™ã‚‹
2. 2 é€²æ•°è¡¨ç¾ã‚’ã‚³ãƒ³ãƒ”ãƒ¥ãƒ¼ã‚¿ãƒ¼ãŒæ‰±ãˆã‚‹å½¢å¼ã«å¤‰æ›ã™ã‚‹

ã‚³ãƒ³ãƒ”ãƒ¥ãƒ¼ã‚¿ãƒ¼ã¯ã€16 é€²æ•°ã‚„ 10 é€²æ•°ãªã©ã®æ•°å€¤è¡¨ç¾ã‚’å†…éƒ¨çš„ã« 2 é€²æ•°ã«å¤‰æ›ã—ã¦æ‰±ã„ã¾ã™ã€‚ãã®ãŸã‚ã€2 é€²æ•°è¡¨ç¾ "0000 0000 0100 0001" ã¯ã€ã‚³ãƒ³ãƒ”ãƒ¥ãƒ¼ã‚¿ãƒ¼ãŒæ‰±ãˆã‚‹å½¢å¼ã§ã‚ã‚Šã€æ©Ÿæ¢°ãŒç†è§£ã§ãã‚‹å½¢å¼ã§ã™ã€‚

`A -> 0041(16é€²æ•°/Unicode/runeå‹) â†’ 0000 0000 0100 0001(2é€²æ•°)`

è¦ã™ã‚‹ã«ä¸Šè¨˜ã®ã‚ˆã†ãªæµã‚Œã«ãªã‚Šã¾ã™ã€‚ãªã®ã§ Unicode ã¯å¿…è¦ã§ã™ã€‚

`unicode.isUpper()`ã¨`unicode.IsDegit()`ã¯ rune ã‚’å¼•æ•°ã«å–ã£ã¦æ¯”è¼ƒãŒå‡ºæ¥ã‚‹ã®ã§ã€

ãã—ã¦æ¡ä»¶ãŒ true ã§ã‚ã‚Œã°ã€ä»¥ä¸‹ã®ã‚ˆã†ã«ãªã‚Šã¾ã™ã€‚

`words[word] = struct{}{}`

ã¾ãšè§£èª¬ã™ã‚‹ã¨ã€

`words := map[string]struct{}{}`

ã¾ãš map ã®ã‚­ãƒ¼ã« stringã€ãƒãƒªãƒ¥ãƒ¼ã«ã¯æ§‹é€ ä½“ãƒªãƒ†ãƒ©ãƒ«ã‚’ç”¨ã„ã¦ã€å®£è¨€ã—ã¦ã„ã¾ã™ã€‚

ã¾ãšç©ºã®æ§‹é€ ä½“å‹ã¨ã—ã¦`struct{}`ã¨ã„ã†å‹ãŒã‚ã‚‹ã¨èªè­˜ã™ã‚Œã° OK ã§ã™ã€‚ãã—ã¦å€¤ã‚‚ä¸€ç·’ã«æ§‹é€ ä½“ãƒªãƒ†ãƒ©ãƒ«ã¨ã„ã†å½¢å¼ã§
åˆæœŸåŒ–ã‚’è¡Œã£ã¦ã„ã¾ã™ã€‚

ãã‚‚ãã‚‚æ§‹é€ ä½“ãƒªãƒ†ãƒ©ãƒ«ã¨ã„ã†ã®ã¯ã€åˆæœŸåŒ–(å®£è¨€ã•ã‚ŒãŸå¤‰æ•°ã«åˆã‚ã¦å€¤ã‚’ä»£å…¥ã™ã‚‹ã“ã¨)ã‚’ã™ã‚‹éš›ã«æ§‹é€ ä½“å‹ã®å€¤ã‚’ä¸€ç·’ã«è¨­å®šã™ã‚‹ãŸã‚ã®æ–¹æ³•ã§ã™ã€‚

ãã—ã¦ã“ã‚ŒãŒã©ã†é‡è¤‡åˆ¤å®šã«åˆ©ç”¨ã§ãã‚‹ã‹ã¨ã„ã†éƒ¨åˆ†ã‚’è§£èª¬ã—ã¦ã„ãã¾ã™ã€‚
ç‰¹ã«ä»Šå›ã®å ´åˆãƒãƒªãƒ¥ãƒ¼ã«ã‚¢ã‚¯ã‚»ã‚¹ã™ã‚‹å¿…è¦ãŒåˆ¥ã«ãªã„ã®ã§ã‚­ãƒ¼ã ã‘ã§åˆ¤æ–­ã—ã‚ˆã†ã¨ã„ã†ã“ã¨ã§ã™ã€‚
ã“ã‚Œã«ã‚ˆã‚Šã€map ã®ã‚­ãƒ¼ã®å­˜åœ¨ã‚’èª¿ã¹ã‚‹ã¨ãã«ãƒ¡ãƒ¢ãƒªä½¿ç”¨é‡ãŒå¤§å¹…ã«å‰Šæ¸›ã•ã‚Œã¾ã™ã€‚

è¨€è‘‰ã§ã¯ã‚¤ãƒ¡ãƒ¼ã‚¸ã¤ã‹ãªã„ã¨æ€ã†ã®ã§ã‚³ãƒ¼ãƒ‰ã§ç¤ºã—ã¾ã™ã€‚

```go
    words := map[string]struct{}{}

    words["key1"] = struct{}{}
    words["key2"] = struct{}{}
    words["key1"] = struct{}{}

    fmt.Println(words)
    // -> map[key1:{} key2:{}]
```

map ã®ã‚­ãƒ¼ã¯é‡è¤‡ã™ã‚‹ã“ã¨ãŒã‚ã‚Šã¾ã›ã‚“ã€‚ãªã®ã§åŒã˜ã‚­ãƒ¼åãŒæ¥ã¦ã‚‚ä¸Šæ›¸ãã•ã‚Œã‚‹ã ã‘ãªã®ã§ãã®ä»•çµ„ã¿ã‚’åˆ©ç”¨ã—ã¦ã„ã‚‹ã ã‘ã§ã™ã€‚
`words := map[string]struct{}{}`

`words[word] = struct{}{}`
ä¸€è‡´ã—ãŸã‚‰ã‚­ãƒ¼ã«ãã®å˜èªã‚’ã€å€¤ã¯ç©ºã§è¨­å®šã—ã¾ã™ã€‚
words ã¨ã„ã† map ã®é›†åˆä½“ã« word ã¨ã„ã†ã‚­ãƒ¼ã‚’è¨­å®šã—ã€ãƒãƒªãƒ¥ãƒ¼ã¯ç©ºã§ã™ã€‚

æœ€å¾Œã« map ã®é›†åˆä½“ã‚’ for range ã§å›ã—ã¦å‡ºåŠ›ã—ã¾ã™ã€‚

### å…¨ä½“ã®ã‚³ãƒ¼ãƒ‰

```go

func otherSolution() {
    scanner := bufio.NewScanner(os.Stdin)

    // ã©ã®ã‚ˆã†ã«åŒºåˆ‡ã‚‹ã‹ã®è¨­å®šã‚’è¡Œã† -> ç©ºç™½ã¨ãƒ”ãƒªã‚ªãƒ‰ã§åŒºåˆ‡ã‚‹
    scanner.Split(func(data []byte, atEOF bool) (advance int, token []byte, err error) {
        for i := 0; i < len(data); i++ {
            if data[i] == ' ' || data[i] == '.' {
                return i + 1, data[:i], nil
            }
        }
        return 0, data, bufio.ErrFinalToken
    })

    words := map[string]struct{}{}
    for scanner.Scan() {
        word := scanner.Text()
        if len(word) == 0 {
            continue
        }
        capital := rune(word[0]) // runeã§æ¯”è¼ƒã—ãŸã„ã®ã§å¤‰æ›ã™ã‚‹
        if unicode.IsUpper(capital) || unicode.IsDigit(capital) {
        // ä¸€è‡´ã—ãŸã‚‰ã‚­ãƒ¼ã«ãã®å˜èªã‚’ã€å€¤ã¯ç©ºã§è¨­å®šã™ã‚‹
            words[word] = struct{}{}
        }
    }
    if err := scanner.Err(); err != nil {
        panic(err)
    }
    fmt.Printf("%d words\n\n", len(words))
    // mapã‚’for range ã§å›ã™
    for word := range words {
        fmt.Println(word)
    }
}
```
