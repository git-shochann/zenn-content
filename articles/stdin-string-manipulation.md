---
title: "Goã§æ–‡å­—åˆ—æ“ä½œã‚’è¡Œã†éš›ã®å…·ä½“çš„ãªå‡¦ç†ã‚’ç´°ã‹ã„ã¨ã“ã‚ã¾ã§è¿½ã£ã¦ã¿ã‚‹"
emoji: "ğŸ˜½"
type: "tech" # tech: æŠ€è¡“è¨˜äº‹ / idea: ã‚¢ã‚¤ãƒ‡ã‚¢
topics: ["go", "golang"] # ã‚¿ã‚°å
published: false # å…¬é–‹è¨­å®š
---

## åˆã‚ã«

ã¨ã‚ã‚‹å•é¡Œé›†ã§ä»¥ä¸‹ã®ã‚ˆã†ãªå•é¡ŒãŒã‚ã‚Šã¾ã—ãŸã€‚

æ–‡ç« ä¸­ã«ã‚¢ãƒ«ãƒ•ã‚¡ãƒ™ãƒƒãƒˆå¤§æ–‡å­—ã¾ãŸã¯æ•°å­—ã‹ã‚‰å§‹ã¾ã‚‹å˜èªãŒä½•ç¨®é¡ã‚ã‚‹ã‹æ•°ãˆã¦ãã ã•ã„ã€‚

ãŸã ã—å˜èªã®å€‹æ•°ãªã®ã§é‡è¤‡ã¯ã‚«ã‚¦ãƒ³ãƒˆã—ã¾ã›ã‚“ã€‚

å…¥åŠ›ã¯æ¨™æº–å…¥åŠ›ã‹ã‚‰å–å¾—ã—ã¦ã€æœ€å¾Œã«å‡ºåŠ›ã—ã¾ã™ã€‚

ex) input

`Favorite food is yakiniku. Age is 25 years old. Favorite hobby is coding.`

ã“ã®å•é¡Œã‚’è§£ãéš›ã«å­¦ã‚“ã ã“ã¨ãŒæ²¢å±±ã‚ã£ãŸã®ã§ã€ã¾ã¨ã‚ã¾ã—ãŸã€‚

## æœ€åˆã«è€ƒãˆãŸã“ã¨

1. ã¾ãšã¯ç©ºç™½ã§æ–‡å­—ã‚’åŒºåˆ‡ã£ã¦æ–°ã—ãã‚¹ãƒ©ã‚¤ã‚¹ã‚’ä½œæˆã™ã‚‹
2. é‡è¤‡ã‚’åˆ¤å®šã™ã‚‹é–¢æ•°ã‚’ç”¨æ„ã—ã¦ã€é‡è¤‡ã‚’å–ã‚Šé™¤ã„ãŸæ–°ã—ã„ã‚¹ãƒ©ã‚¤ã‚¹ã‚’ä½œæˆã™ã‚‹
3. ã‚¹ãƒ©ã‚¤ã‚¹ã‚’ range ã§å›ã—ã¦ã„ãã€æ–‡å­—ã‚’å–å¾—ã—ã¦ã€å¤§æ–‡å­—ã‹å°æ–‡å­—ã‹åˆ¤å®šã™ã‚‹

ã“ã®ã‚ˆã†ã«æœ€åˆã«æ•´ç†ã—ã¦ã€ãƒ­ã‚¸ãƒƒã‚¯ã‚’è€ƒãˆã¾ã—ãŸã€‚

æœ€åˆã«å…¨ã¦ã®ã‚³ãƒ¼ãƒ‰ã‚’æç¤ºã—ã¦ã‚‚åˆ†ã‹ã‚Šè¾›ã„ã®ã§ã€main é–¢æ•°ã‹ã‚‰æœ€å¾Œã¾ã§åˆ‡ã‚Šåˆ†ã‘ã¦è§£èª¬ã—ã¾ã™ã€‚

## ã‚¨ãƒ³ãƒˆãƒªãƒ¼ãƒã‚¤ãƒ³ãƒˆ (main é–¢æ•°)

```go
func main() {
    scanner := bufio.NewScanner(os.Stdin)
    scanner.Scan()
    text := scanner.Text()
    fmt.Printf("Solution(text): %v\n", Solution(text))
}
```

`func NewScanner(r io.Reader) *Scanner`

Scanner å‹ã¯ã€æ¨™æº–å…¥åŠ›ã‚„ãƒ•ã‚¡ã‚¤ãƒ«ã‹ã‚‰ã®ãƒ‡ãƒ¼ã‚¿ã®èª­ã¿è¾¼ã¿ã‚„ã€æ–‡å­—åˆ—ã‚’æŒ‡å®šã®åŒºåˆ‡ã‚Šã§åˆ†å‰²ã™ã‚‹æ©Ÿèƒ½ã‚’æä¾›ã—ã¦ãã‚Œã¾ã™ã€‚
å¼•æ•°ã«ã¯ io.Reader å‹ => io.Reader interface ã¯ã€èª­ã¿è¾¼ã¿å¯èƒ½ãªãƒ‡ãƒ¼ã‚¿ã‚’è¡¨ç¾ã™ã‚‹ãŸã‚ã®ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹ã‚’æä¾›ã—ã¾ã™ã€‚
ãªã®ã§èª­ã¿å–ã‚Šå¯èƒ½ãªãƒ‡ãƒ¼ã‚¿ã‚’å¼•æ•°ã«ã¨ã£ã¦ã‚ã’ã¾ã™ã€‚
ã“ã“ã§è¨­å®šã™ã‚‹ os.Stdin ã¯ã€æ¨™æº–å…¥åŠ›ã‚’è¡¨ã™ os.File å‹ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã§ã‚ã‚Šã€
`Stdin = NewFile(uintptr(syscall.Stdin), "/dev/stdin")`
`func NewFile(fd uintptr, name string) *File`ã§ã™ã€‚

bufio.NewScanner()ã«æ¸¡ã™ã“ã¨ã§ã€æ¨™æº–å…¥åŠ›ã‹ã‚‰èª­ã¿è¾¼ã¿ã‚’è¡Œã†ã‚ˆã¨æœ€åˆã«è¨­å®šã—ã¾ã™ã€‚

- ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ
  ã€ŒScanner å‹ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’ä½œæˆã™ã‚‹ã€ã¨ã„ã†è¡¨ç¾ã«ãŠã„ã¦ã€ã“ã®ã€Œã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã€ã¨ã¯å¤‰æ•°ã‚„é–¢æ•°ã€æ§‹é€ ä½“ãªã©ã®å®Ÿä½“ã®ã“ã¨ã§ã™ã€‚
  è¦ã™ã‚‹ã«ã€æ§‹é€ ä½“ã®ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ç­‰ã‚’åŸ‹ã‚ã‚‹ä½œæ¥­ã‚’è¡Œã„ã€å®Ÿä½“ã‚’ä½œæˆã™ã‚‹ã¨ã„ã†ã“ã¨ã«ãªã‚Šã¾ã™ã€‚

`scanner.Scan()`

scanner.Scan()ã¯ã€å®Ÿéš›ã®æ¨™æº–å…¥åŠ›ã‹ã‚‰ãƒ‡ãƒ¼ã‚¿ã‚’èª­ã¿å–ã‚Šã€ãã®ãƒ‡ãƒ¼ã‚¿ã‚’ç©ºç™½æ–‡å­—ã§åŒºåˆ‡ã£ã¦ 1 ã¤ã®ãƒˆãƒ¼ã‚¯ãƒ³ã¨ã—ã¾ã™ã€‚

ãã®ãƒˆãƒ¼ã‚¯ãƒ³ã¯ scanner ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã® token ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã«ä¸€æ™‚çš„ã«ä¿æŒã—ã¾ã™ã€‚

æ§‹é€ ä½“ã®ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã«ãƒˆãƒ¼ã‚¯ãƒ³ã¨ã—ã¦ä¿å­˜ã™ã‚‹ã ã‘ãªã®ã§ã€ç‰¹ã«æˆ»ã‚Šå€¤ã®åˆ©ç”¨ã¯ãªã„å‡¦ç†ã«ãªã‚Šã¾ã™ã€‚

`text := scanner.Text()`

scanner.Scan()ã§ scanner æ§‹é€ ä½“ã® token ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã‚’èª­ã¿å–ã‚Šã€èª­ã¿è¾¼ã‚“ã ãƒˆãƒ¼ã‚¯ãƒ³ã‚’æ–‡å­—åˆ—ã¨ã—ã¦è¿”ã—ã¾ã™ã€‚

## å®Ÿéš›ã«å‡¦ç†ã™ã‚‹éƒ¨åˆ†

```go
func Solution(str string) int {

    slice := strings.Split(str, " ")
    uniqueSlice := DeleteDuplicate(slice) // é‡è¤‡ã®å‰Šé™¤
    for _, v := range uniqueSlice {
        // [M3 2000 sho tsuboya]
        initial := v[0:1]
    ok := CheckRegex(initial)
    if ok {
        count++
    }
    }
    return count
}
```

`slice := strings.Split(str, " ")`
ã“ã“ã§ã¯ã¾ãšã€1 ã¤ 1 ã¤ã®å˜èªã«ã‚¢ã‚¯ã‚»ã‚¹ã™ã‚‹ãŸã‚ã€é•·ã„ 1 ã¤ã®æ–‡å­—åˆ—ã‚’ç©ºç™½å˜ä½ã§ Go ã®ã‚¹ãƒ©ã‚¤ã‚¹ã«å¤‰æ›ã—ã¾ã™ã€‚

ãã®çµæœã®å¤‰æ•° slice ã¯ä»¥ä¸‹ã®ã‚ˆã†ãªå€¤ã‚’æŒã£ã¦ã„ã¾ã™ã€‚

`["Favorite" "food" "is" "yakiniku." "Age" "is" "25" "years" "old." "Favorite" "hobby" "is" "coding."]`

ãã®å¾Œã€é‡è¤‡ã‚’å‰Šé™¤ã™ã‚‹é–¢æ•°ãŒå‘¼ã³å‡ºã•ã‚Œã¾ã™ã€‚

```go
func DeleteDuplicate(strings []string) []string {
    var unique []string
    m := map[string]bool{}
    for _, v := range strings {
        if _, ok := m[v]; !ok {
            m[v] = true
            unique = append(unique, v)
        }
    }
    return unique
}
```

ã¾ãšé‡è¤‡ã‚’é™¤ã„ãŸã‚¹ãƒ©ã‚¤ã‚¹ã‚’æ–°ã—ãä½œæˆã—ãŸã„ã®ã§`var unique []string`ã¨å®£è¨€ã—ã¾ã™ã€‚

ã“ã“ã§ã®ãƒã‚¤ãƒ³ãƒˆã¯ã©ã†é‡è¤‡ã—ã¦ã„ã‚‹ã‹ã©ã†ã‹ã‚’åˆ¤å®šã™ã‚‹ã‹ã¨ã„ã†ã“ã¨ã§ã™ã€‚
`m := map[string]bool{}`ã¨ã„ã†å¤‰æ•°ã‚’ç”¨æ„ã—ã¦ã€ã“ã¡ã‚‰ã‚’ä½¿ã„ã¾ã™ã€‚
ã¾ãš map å‹ã®æ€§è³ªã¨ã—ã¦ã€åŒã˜ã‚­ãƒ¼ãŒä¿å­˜ã•ã‚Œã‚‹ã“ã¨ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚

```go
    m := make(map[string]int)
    m.key1 = 1
    m.key2 = 2
    m.key1 = 5 // ä¸Šæ›¸ãã™ã‚‹

    fmt.Println(m)
    // -> [key1: 5, key2: 2]
```

ç©ºç™½ã§åŒºåˆ‡ã‚‰ã‚ŒãŸæ–‡å­—åˆ—ã®ã‚¹ãƒ©ã‚¤ã‚¹ã‚’ãã‚Œãã‚Œã‚¢ã‚¯ã‚»ã‚¹ã—ã¦ã„ã£ã¦ã€é‡è¤‡ãŒã©ã†ã‹ã‚’åˆ¤å®šã—ã¾ã™ã€‚
m[v] -> m["Favorite"] ã¨ã‚­ãƒ¼ã«ã‚¢ã‚¯ã‚»ã‚¹ã—ã€map ã®ãƒãƒªãƒ¥ãƒ¼ãŒ true ã‹ false ã§åˆ¤å®šã—ã¾ã™ã€‚
è¦ã™ã‚‹ã« true ã§ã‚ã‚Œã°æ—¢ã«ã‚­ãƒ¼ã¯å­˜åœ¨ã—ã¦ã„ã‚‹ã¨ã„ã†ã“ã¨ã«ãªã‚Šã¾ã™ã€‚
ã“ã®ã‚ˆã†ã«å˜èªåˆ†ç¹°ã‚Šè¿”ã—ã¦ã„ãã€é‡è¤‡ã‚’é™¤ã„ãŸã‚¹ãƒ©ã‚¤ã‚¹ã‚’ æˆ»ã‚Šå€¤ã¨ã—ã¦è¿”ã—ã¾ã™ã€‚

```go
func Solution(str string) int {

    slice := strings.Split(str, " ")
    uniqueSlice := DeleteDuplicate(slice) // é‡è¤‡ã®å‰Šé™¤

    // ã“ã“ã¾ã§OK

    for _, v := range uniqueSlice {
        // [M3 2000 sho tsuboya]
        initial := v[0:1]
    ok := CheckRegex(initial)
    if ok {
        count++
    }
    }
    return count
}
```

ã•ã‚‰ã«é‡è¤‡ã‚’é™¤ã„ãŸã‚¹ãƒ©ã‚¤ã‚¹ã‚’ for range ã§å›ã—ã¦ã€v[0:1]ã¨ã—ã¦é ­æ–‡å­—ã«ã‚¢ã‚¯ã‚»ã‚¹ã—ã¾ã™ã€‚
ãã—ã¦ CheckRegex()ã¨ã—ã¦é–¢æ•°ã‚’ç”¨æ„ã—ã¾ã™ã€‚

```go
regex := regexp.MustCompile(`[A-Z0-9]`) // æº–å‚™

func CheckRegex(s string) bool {
    ok := regex.MatchString(s)  // åˆ¤å®š
    return ok
}
```

ã“ã“ã§åˆ¤å®šã‚’è¡Œã„ã¾ã™ã€‚å°š `regex := regexp.MustCompile(`[A-Z0-9]`)` ã¯ä¸€åº¦ã®ã¿ã®å®Ÿè¡Œã§ã„ã„ã®ã§ CheckRegex()å¤–ã§å®£è¨€ã—ã¦ã„ã¾ã™ã€‚
regex.MatchString()ã§ true ã§ã‚ã‚Œã°å¤§æ–‡å­— or æ•°å­— ã¨ã—ã¦ã‚«ã‚¦ãƒ³ãƒˆã—ã¦æœ€å¾Œã«å‡ºåŠ›ã—ã¦çµ‚äº†ã§ã™ã€‚

## å…¨ä½“ã®ã‚³ãƒ¼ãƒ‰

```go
package main

import (
    "bufio"
    "fmt"
    "os"
    "regexp"
    "strings"
)

var count int

func Solution(str string) int {

    slice := strings.Split(str, " ")
    fmt.Printf("slice: %v\n", slice)
    uniqueSlice := DeleteDuplicate(slice) // é‡è¤‡ã®å‰Šé™¤
    fmt.Printf("uniqueSlice: %v\n", uniqueSlice)
    for _, v := range uniqueSlice {
        // [M3 2000 sho tsuboya]
        initial := v[0:1]
        ok := CheckRegex(initial)
        if ok {
            count++
        }
    }
    return count
}

// [M3 2000 sho tsuboya M3]
func DeleteDuplicate(strings []string) []string {
    // m[""]false ãŒåˆæœŸåŒ–ã—ãŸéš›ã®å‹
    m := make(map[string]bool)

    // ä¸€å¿œmap[string]struct{}{}ã®æ–¹ãŒã„ã„ã‹ã‚‚ã—ã‚Œãªã„ å€¤ã«ã‚¢ã‚¯ã‚»ã‚¹ã—ãªãã¦ã‚‚ã„ã„ã®ã§
    // è©³ç´°ã¯ # other_solution.goã‚’å‚ç…§

    var unique []string
    for _, v := range strings {
        // m[v]ãŒtrueã§ãªã‘ã‚Œã° = ã¾ã ãã®ã‚­ãƒ¼ã¯ãªã„ã¨ã„ã†ã“ã¨
        if _, ok := m[v]; !ok {
            m[v] = true
            unique = append(unique, v)
        }
    }
    return unique

}

var regex = regexp.MustCompile(`[A-Z0-9]`) // æº–å‚™

func CheckRegex(s string) bool {
    ok := regex.MatchString(s) // åˆ¤å®š
    return ok
}
```

## ä¸Šè¨˜ã®æ”¹å–„ç‚¹

ä¸€å¿œä¸Šè¨˜ã§ã®ã‚³ãƒ¼ãƒ‰ã§ã‚‚å‹•ãã®ã§ã™ãŒã€

string.Split()ã§ã‚‚å…¨ã¦ã‚’èª­ã¿è¾¼ã‚€ã¨ãªã‚‹ã¨ã€ãƒ†ã‚­ã‚¹ãƒˆãƒ•ã‚¡ã‚¤ãƒ«ã®ã‚µã‚¤ã‚ºãŒå¤§ãã„ã¨å¤‰æ•°ã®å®¹é‡ã‚‚å¢—åŠ ã—ã€
å¤‰æ•°ã®ã‚µã‚¤ã‚ºãŒå¤§ãããªã‚‹ã¨ãƒ¡ãƒ¢ãƒªç¢ºä¿ã‚„ã‚³ãƒ”ãƒ¼ãªã©ã«æ™‚é–“ãŒã‹ã‹ã‚Šã¾ã™ã€‚

ä»Šå›å…¨ã¦ã®ãƒ†ã‚­ã‚¹ãƒˆæƒ…å ±ã‚’ä¿æŒã—ãªãã¦ã‚‚ã€æ–‡å­—åˆ—ã‚’ã‚¹ãƒšãƒ¼ã‚¹ç­‰ãŒãã‚‹ã¾ã§é †ç•ªã«èª­ã¿å–ã£ã¦å‡¦ç†ã‚’è¡Œã„ã€
å˜èªã®é‡è¤‡ãƒã‚§ãƒƒã‚¯ã‚’è¡Œãªã£ã¦ã„ãã“ã¨ã§æ—¢ã«å‡¦ç†ã—ãŸæ–‡å­—åˆ—ã‚’ç ´æ£„ã™ã‚‹ã“ã¨ãŒå‡ºæ¥ã‚‹ã‚ˆã†ãªãƒ­ã‚¸ãƒƒã‚¯ã§ã‚‚æ›¸ãã“ã¨ãŒå‡ºæ¥ã¾ã—ãŸã€‚

## å…¨ä½“ã®ã‚³ãƒ¼ãƒ‰

```go

func otherSolution() {
    scanner := bufio.NewScanner(os.Stdin)

    // ã©ã®ã‚ˆã†ã«åŒºåˆ‡ã‚‹ã‹ã®è¨­å®šã‚’è¡Œã†
    scanner.Split(func(data []byte, atEOF bool) (advance int, token []byte, err error) {
        // ç©ºç™½ã§åŒºåˆ‡ã‚‹
        for i := 0; i < len(data); i++ {
            if data[i] == ' ' || data[i] == '.' {
                return i + 1, data[:i], nil
            }
        }
        return 0, data, bufio.ErrFinalToken
    })

    words := map[string]struct{}{}
    for scanner.Scan() {
        word := scanner.Text()
        initial := word[0]
        if 'A' <= intial && 'Z' <= initial || '0' <= initial && '9' {
            words[word] = struct{}{}
        }
    }
}


```

æœ€åˆã«`words := map[string]struct{}{}`ã¨ã‚ã‚Šã¾ã™ãŒã€ã“ã¡ã‚‰ã‚‚é‡è¤‡ã‚’ãƒã‚§ãƒƒã‚¯ã™ã‚‹ãŸã‚ã«ç”¨æ„ã—ã¦ã„ã¾ã™ã€‚å¾Œã»ã©èª¬æ˜ã—ã¾ã™ã€‚

ã¾ãšã€scanner.Scan()ã¯æ¨™æº–å…¥åŠ›ç©ºç™½ã§åŒºåˆ‡ã£ã¦(ç©ºç™½ä»¥å¤–ã®åŒºåˆ‡ã‚Šã«ã‚‚å‡ºæ¥ã‚‹ãŒãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã¯ç©ºç™½)ã€ãƒ‡ãƒ¼ã‚¿ã‚’ç©ºç™½æ–‡å­—ã§åŒºåˆ‡ã£ã¦ 1 ã¤ã®ãƒˆãƒ¼ã‚¯ãƒ³ã¨ã—ã¾ã™ã€‚
ãã®ãƒˆãƒ¼ã‚¯ãƒ³ã¯ scanner ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã® token ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã«ä¸€æ™‚çš„ã«ä¿æŒã—ã¾ã™ã€‚ãªã®ã§ã“ã‚Œã‚’åˆ©ç”¨ã—ã¦ã€1 ã¤ 1 ã¤æ–‡å­—ã‚’è¦‹ã¦ã„ã‘ã°ã„ã„ã ã‘ã§ã™ã€‚
ãã—ã¦`initial := word[0]` ã“ã¡ã‚‰ã§å˜èªã®é ­æ–‡å­—ã«ã‚¢ã‚¯ã‚»ã‚¹ã—ã¾ã™ã€‚

<!-- ã“ã“ã«å…¥ã‚Œã‚‹ -->

ãã—ã¦æ¡ä»¶ãŒ true ã§ã‚ã‚Œã°ã€ä»¥ä¸‹ã®ã‚ˆã†ã«ãªã‚Šã¾ã™ã€‚

`words[word] = struct{}{}`

ã¾ãšè§£èª¬ã™ã‚‹ã¨ã€

`words := map[string]struct{}{}`

ã¾ãš map ã®ã‚­ãƒ¼ã« stringã€ãƒãƒªãƒ¥ãƒ¼ã«ç©ºã®æ§‹é€ ä½“å‹ struct{}ã§{}ã¨ã™ã‚‹ã“ã¨ã§ãã®å€¤ã¯ç©ºã¨è¡¨ç¾å‡ºæ¥ã¾ã™ã€‚

ã“ã¡ã‚‰ã§ã‚‚é‡è¤‡ã‚’åˆ¤å®šã™ã‚‹ã“ã¨ãŒå‡ºæ¥ã¾ã™ã€‚ç‰¹ã«ä»Šå›ã®å ´åˆãƒãƒªãƒ¥ãƒ¼ã«ã‚¢ã‚¯ã‚»ã‚¹ã™ã‚‹å¿…è¦ãŒåˆ¥ã«ãªã„ã®ã§
ã‚­ãƒ¼ã ã‘ã§åˆ¤æ–­ã—ã‚ˆã†ã¨ã„ã†ã“ã¨ã§ã™ã€‚
ã“ã‚Œã«ã‚ˆã‚Šã€map ã®ã‚­ãƒ¼ã®å­˜åœ¨ã‚’èª¿ã¹ã‚‹ã¨ãã«ãƒ¡ãƒ¢ãƒªä½¿ç”¨é‡ãŒå¤§å¹…ã«å‰Šæ¸›ã•ã‚Œã‚‹ãã†ã§ã™ã€‚

```go
    words := map[string]struct{}{}

    words["key1"] = struct{}{}
    words["key2"] = struct{}{}
    words["key1"] = struct{}{}

    fmt.Println(words)
    // -> map[key1:{} key2:{}]
```
